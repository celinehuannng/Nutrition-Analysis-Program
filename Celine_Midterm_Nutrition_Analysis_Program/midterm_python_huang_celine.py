# -*- coding: utf-8 -*-
"""MidtermProject_Huang_Celine.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1FT1VZHYzFbzHGBzQl_cttfEt3bPgXHZX
"""

###################################################################
# University of Toronto
# Faculty of Information
# Master of Information Program
# INF 1340H - Programming for Data Science
# Student Name: <Celine Huang>
# Student Number: <1006746327>
#
#
#
# Midterm Project: Nutritional Analysis Program
# Purpose: <Numerical Analysis>
# Date Created: <Oct 3, 2024>
# Date Modified: <Oct 18, 2024>
###################################################################

# Commented out IPython magic to ensure Python compatibility.
# Import the 'drive' module from the 'google.colab' package to enable Google Drive integration.
# Then, mount Google Drive to the '/drive' directory within the Colab environment.
# The 'force_remount=True' parameter ensures that the Drive is remounted even if it was previously mounted.
from google.colab import drive
drive.mount('/drive', force_remount=True)
# %cd '/drive/My Drive/Colab Notebooks/Midterm/'

import pandas as pd # import pandas as pd into memory

# prompt user to enter input file
file = input("Enter the file name (FOOD-DATA-GROUP(1,2,3,4, or 5).csv):")

# define a function for inputing data from a file
def input_data(file):
  # read the CSV file into a Dataframe
  df = pd.read_csv(file)
  return df # return the DataFrame containing the data from the CSV file.

# call input_data() and drop the first two columns
df = input_data(file).iloc[:,2:]
# save the updated csv file without the index
df.to_csv(file, index = False)

# Define a function for finding the largest value of a nutrient category and its corresponding foods
def largest_value(category):
  # read a specific column of the csv file and set column "food" as index
  df = pd.read_csv(file, usecols = [category,'food'], index_col = "food")
  # initialize the food name with the first food from the index
  first_food = df.index[0]
  largest_value = df[category].iloc[0] # initialize largest_value with first value of the column
  largest_value_row = [first_food] # initialize a list to store foods
  for food in df.index: # iterate through food names
    value = df.loc[food,category] # retrieve the nutrient value for the current food item
    if value > largest_value: # compare the current value with the largest value
      largest_value = value # update largest_value if the current value is larger
      largest_value_row = [food] # update the row index of the largest value
    elif value == largest_value: # if the current value is the same as the largest value
      largest_value_row.append(food) # add the current food to the list of foods with the largest value
  return largest_value, largest_value_row # return the largest value and its associated rows

# Define a function for finding the smallest value of a nutrient category and its corresponding foods
def smallest_value(category):
  # read a specific column of the csv file while setting column "food" as index
  df = pd.read_csv(file,usecols= [category,'food'], index_col = 'food')
  # initialize the food name with the first food from the index
  first_food = df.index[0]
  smallest_value = df[category].iloc[0] # initialize smallest_value with first value of the column
  smallest_value_row = [first_food] # initialize a list to store foods
  for food in df.index: # iterate through food names
    value = df.loc[food, category] # retrieve the nutrient value for the current food item
    if value < smallest_value: # compare the current value with the smallest value
        smallest_value = value # update smallest_value if the current value is smaller
        smallest_value_row = [food] # update the row index of the smallest value
    elif value == smallest_value: # if the current value is the same as the smallest value
        smallest_value_row.append(food) # add the current food to the list of foods with the smallest value
  return smallest_value, smallest_value_row # return the smallest value and its associated rows

# Define a function for calculating key nutrient ratios
def nutrient_ratios(category1, category2, food):
  df = pd.read_csv(file, index_col = 'food') # read the csv file and set column "food" as index
  # validate if the nutrient categories exist
  if category1 not in df.columns or category2 not in df.columns:
    raise ValueError (f"One or both categories: {category1} and {category2} not found in the dataset")
  # validate if the food exists
  if food not in df.index:
    raise ValueError (f"Food {food} not found in the dataset")
  # access the data using the index labels and column names
  value1 = df.loc[food, category1] # get the first value of category1
  value2 = df.loc[food, category2] # get the first value of category 2
  # check for zeros or NaN values to avoid invalid operations
  if value2 == 0:
    raise ValueError ("Division by zero error: the value of the second category is zero")
  # calculate the nutrient ratio
  ratio = value1 / value2
  if ratio == 0:
    print ("The ratio is 0")
  return ratio # return ratio

# Define a function to calculate the mode of a nutrient category
def mode(category):
  df = pd.read_csv(file, usecols=[category]) # read a specific column of the csv file
  y = {} # create an empty dictionary to store the count of each value
  for value in df[category]: # iterate through each value in a column
    if value not in y: # if the value is not in the dictionary, add it with a count of 1
      y[value] = 1
    else: # if the value is already in the dictionary, increment it by a count of 1
      y[value] += 1
  # find the mode by identifying the key with the highest count
  mode_value = None # initialize variable for storing the mode value
  max_count = 0 # initialize variable for tracking highest count of values
  for value, count in y.items(): # iterate through each key-value pair in dictionary
    if count > max_count: # if the count is greater then the current max_count
      max_count = count # update max_count
      mode_value = value # set mode_value to current value
  return mode_value # return the mode value

# Define a function to calculate the median of a nutrient category
def median(category):
  df = pd.read_csv(file, usecols = [category]) # read a specific column of the csv file
  # extract the values of the specified nutrient category into a list
  values = df[category].tolist()
  values.sort() # sort the values
  # find the values
  n = len(values) # get the number of values in the list
  if n % 2 == 1: # if the number of values is odd
    return values[n // 2] # return the middle value
  else: # if the number of values is even
    return (values[n // 2 - 1] + values[n // 2]) / 2 #return the average of the two middle numbers

# Define a function for calculating the mean of a nutrient category
def mean(category):
  df = pd.read_csv(file, usecols = [category]) # read a specific column of the csv file
  total = 0 # initialize variable for storing sum of numbers
  count = 0 # initialize variable for storing count of numbers
  for value in df[category]: # iterate through each value in a column
    total += value # add the value to the sum
    count += 1 # increment the count by 1
    mean = total / count # calculate the mean
  return mean # return the mean

# Define a function for finding the total amount for a specific nutrition category
def total_amount(category):
  df = pd.read_csv(file, usecols = [category]) # read a specific column of the csv file
  total = 0 # initialize variable for storing numbers
  for value in df[category]: # iterate through each value in a category
    total += value # add the value to the sum
  return total # return the total

# Define a function for calculating the standard deviation within a nutrition category
def standard_deviation(category):
  df = pd.read_csv(file, usecols = [category]) # read a specific column of the csv file
  # calculate the mean first
  total = 0 # initialize variable for storing sum of numbers
  count = 0 # initialize variable for count of numbers
  for value in df[category]: # iterate through each value in a category
      total += value # add the value to the total
      count += 1 # increment the count by 1
      mean = total/count # calculate the mean
  # calculate the sum of the squared differences from the mean
  sum_squared_diff = 0 # initialize variable for containing sum of the squared differences
  for value in df[category]: # iterate through each value in a category
      sum_squared_diff += (value - mean) ** 2
  # calculate the standard deviation
  standard_deviation = (sum_squared_diff / (count - 1)) ** 0.5
  return standard_deviation # return the standard deviation

# List to store all outputs
results = []

# Define function to output results into a file
def output_results(file):
  with open(outputfile, 'w') as f: # open the output file in write mode
    for result in results: # iterate over each result in the results list
      f.write(result + '\n') # write each result to the file followed by a newline
  print(f"Results have been written to {outputfile}") # print statement confirming results have been written to the file

# Prompt for user to input an action
command = input('actions:')
while command not in ('','/'):
  if command == '+':
    category = input("Enter the nutrition category with first letter capitalized:") # prompt user to enter nutrition category
    largest,largest_food, = largest_value(category) # call largest_value()
    result = f"Largest value of {category}:{largest}, Food: {largest_food}\n" # format the result string
    results.append(result) # add the result to the results list
    print(result) # print the result
  elif command == '-':
    category = input("Enter the nutrition category with first letter capitalized:") # prompt user to enter nutrition category
    smallest, smallest_food = smallest_value(category) # call smallest_value()
    result = f"Smallest value of {category}:{smallest}, Food: {smallest_food}\n" # format the result string
    results.append(result) # add the result to the results list
    print(result) # print the result
  elif command == '@':
    # prompt user to input key nutrient pairs
    print("Please enter the key nutrients in pairs as suggested")
    # display the key nutrient pairs to the user
    print("1. Calcium and Magnesium")
    print("2. Potassium and Sodium")
    print("3. Zinc and Copper")
    print("4. Iron and Copper")
    category1 = input("Enter the first key nutrient (Calcium/Potassium/Zinc/Iron):") # prompt user to enter first key nutrient
    category2 = input("Enter the second key nutrient (Magnesium/Sodium/Copper/Copper):") # prompt user to enter second key nutrient
    food = input("Enter the food:").lower() # prompt user to enter food
    try:
      ratio = nutrient_ratios(category1, category2, food) # call calculate_nutrient_ratios()
      result = f"The ratio for {category1} and {category2} of {food} is {ratio:.2f}\n" # format the result string
      results.append(result) # add the result to the results list
      print(result) # print the result
    except ValueError as e:
      print(e) # print error message
  elif command == '*':
    category = input("Enter the nutrition category with first letter capitalized:") # prompt user to enter nutrition category
    mode_value = mode(category) # call calculate_mode()
    result = f"The mode of {category} is: {round(mode_value)}\n" # format the result string
    results.append(result) # add the result to the results list
    print(result) # print the result
  elif command == '&':
    category = input("Enter the nutrition category with first letter capitalized:") # prompt user to enter nutrition category
    median_value = median(category) # call calculate_media()
    result = f"The median of {category} is: {round(median_value)}\n" # format the result string
    results.append(result) # add the result to the results list
    print(result) # print the result
  elif command == '?':
    category = input("Enter the nutrition category with first letter capitalized:") # prompt user to enter nutrition category
    mean_value = mean(category) # call mean()
    result = f"The mean of {category} is: {round(mean_value)}\n" # format the result string
    results.append(result) # add the result to the results list
    print(result) # print the result
  elif command == "$":
    category = input("Enter the nutrition category with first letter capitalized:") # prompt user to enter nutrition category
    total_value = total_amount(category) # call total_amount()
    result = f"The total amount of {category} is:{total_value}\n" # format the result string
    results.append(result) # add the result to the results list
    print(result) # print the result
  elif command == "!":
    category = input("Enter the nutrition category with first letter capitalized:") # prompt user to enter nutrition category
    standard_deviation_value = standard_deviation(category) # call standard_deviation()
    result = f"The standard deviation of {category} is: {round(standard_deviation_value)}\n" # format the result string
    results.append(result) # add the result to the results list
    print(result) # print the result
  elif command == "^":
    # Prompt user to enter output file
    outputfile = input("Enter the output file name specific_nutrition_info.txt:")
    output_results(file) # call output_results()
  elif command == "/":
    print("Program has ended") # print message for ending program
  else:
    print("Invalid command, please input +, -, @, *, &, ? , $ , ! ,^, or /") # print error message
  command = input('actions:') # prompt for user to input an action again